## Многопоточность. Часть 2
## Стандартные классы для работы с многопоточностью.

Все переменные существуют в основной памяти. Каждый поток JAVA использует свою собственную рабочую память. Рабочая память хранит копию переменных основной памяти. Т.е. сначала копируются переменные основной памяти и только после этого, поток начинает работать с ними (с копиями). Это означает, что если внутри потока произошли изменения переменной, то они, изменения, видны только внутри потока. Другие потоки не знают об этих изменениях, т.к. они хранят **КОПИЮ** переменной. А "оригинал" в основной памяти остался в том же состоянии. 

Если нам нужно, что бы для всех потоков была только одна переменная (если один поток изменит переменную, то она изменится во всех потоках), то нам нужно отключить ее кэширование, т.е. отключить, у данной переменной, возможность создания рабочей копии для потока. Для этого используется ключевое слово **volatile** :

* Операции чтения/записи **volatile** переменной являются атомарными.

	Что такое **атомарность**? **Атомарнная операция** - это операция в общей области памяти которая завершается в один шаг относительно других потоков, имеющих доступ к этой памяти. Во время выполнения такой операции над переменной, ни один поток не может наблюдать изменение наполовину завершенным. Атомарная загрузка гарантирует, что переменная будет загружена целиком в один момент времени.

	> Во время выполнения атомарной операции ни один поток не успеет считать переменную, пока не закончится атомарная операция. Т.е. поток не сможет увидеть промежуточный вариант значения переменной. Либо поток считывает старое значение (до атомарной операции), либо новое, когда выполнение атомарной операции завершено. Третьего не дано

* Об изменение **volatile** переменной в одном потоке известно всем потоками. Т.е. потоки работают всегда с актуальным значением.

```JAVA
//Данный класс реализует паттерн Singleton - можно создать только один объект данного класса. 
//Но это не работает с многопоточностью, т.к. у каждого потока своя память и в каждом потоке 
//можно создать объект NonMultiThreadSingleton
public class NonMultiThreadSingleton {
    
    private static Singleton instance;
    private String message;

    private Singleton(String message) {
        this.message = message;
    }

    public static Singleton getInstance(String message) {
        if (instance == null) {
            instance = new Singleton(message);
        }
        return instance;
    }

    public String getMessage() {
        return message;
    }
}


//А это уже многопоточный "Одиночка"
public class MultiThreadSingleton {
    //volatile - Отключает кэширование у поля. Т.е. оно становится общим для всех потоков.
    private static volatile Singleton instance;
    private String message;

    private Singleton(String message) {
        this.message = message;
    }

    public static Singleton getInstance(String message) {
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton(message);
            }
            return instance;
        }
    }

    public String getMessage() {
        return message;
    }
}
```

Следующая проблема - в программе могут быть "критические" точки. Когда с данными будут пытаться работать несколько потоков одновременно. Проблемы могут быть разного уровня, от неккоректной записи переменной до поломки программы. Самый простой способ избежать этого - ключевое слово **synchronized**. Для понимания прнципа работы **synchronized** нужно знать, что:

* У **ВСЕХ** классов Java есть мьютекс. Мьютекс - это специальный объект для синхронизации потоков. Задача мьютекса — обеспечить, чтобы доступ к объекту в определенное время был только у одного потока. 
* Так же, у каждого мьютекса есть **монитор** - надстройка над мьютексом, которая как раз и отвечает за "защитный механизм", что бы к объекту был доступ, одновременно, только у одного потока.


Так вот, ключевое слово **synchronized** забирает **мьютекс** у объекта и отдает его потоку, которому нужно отработать в данном блоке кода. Пока поток, которому отдали мьютекс, работает в данном блоке кода, никакой другой поток зайти в этот блок кода не может, т.к. мьютекс занят. (Аналогия с туалетной кабинкой, пока кто то внутри есть, внутрь попасть нельзя).

> **synchronized (У КАКОГО ОБЪЕКТА ОТОБРАТЬ МЬЮТЕКС) {
	//блок кода
}**

```JAVA
class TestSynchronized {
	//Конструкторы, геттеры и сеттеры не указаны, т.к. не имеют смысловой нагрузки в данной теме
	private SomeClass someClass;

	public void testMethod() {
		synchronized(someClass) {
			//Блок кода, который может выполняться одновременно только одним потоком
		}
	}
}

//Но что делать, если у нас нет объекта, который нужно превратить в "туалетную кабинку" (у кого отобрать мютекс)? Можно отобрать мьютекс у класса.

class TestSynchronized {
	//Конструкторы, геттеры и сеттеры не указаны, т.к. не имеют смысловой нагрузки в данной теме
	private SomeClass someClass;

	public void testMethod() {
		synchronized(SomeClass.class) {
			//Блок кода, который может выполняться одновременно только одним потоком
		}
	}
}
```

### Семафор

* **Семафор** - нужен для синхронизации доступа к какому-либо ресурсу. Особенность в том, что мы можем указать, сколько потоков одновременно могут получить доступ к ресурсу.

```JAVA
class ForSemaphore {
	public static void main(String[] args) {
		Semaphore sem = new Semaphore(10); //Сколько потоков одновременно может пропустить семафор к ресурсу
		//каждому потоку нужно отметиться в семафоре, вызвав метод .acquire()
		//таким способ поток берет пропуск к ресурсу,а у семафора счетчик уменьшеаетсся на один
		//и как только счетчик станет равен 0, больше семафор не будет никого впускать 
		//После того, как поток "с пропуском" закончил работать с ресурсом, ему нужно
		//отдать "пропуск" обратно - .release(). После вызова данного метода, у семафора
		//счетчик увеличится на один, и он сможет впустить еще один поток.
	}
}
```