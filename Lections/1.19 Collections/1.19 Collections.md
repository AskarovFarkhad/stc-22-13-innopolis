## Collection

**Java Collection Framework** - иерархия интерфейсов, которая позволяет разработчику пользоваться большим количеством структур данных из "коробки".

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: **Collection** и **Map**. Эти интерфейсы разделяют все коллекции, входящие во фреймворк 
на две части по типу хнанения данных: 
* простые последовательные наборы элементов
* наборы пар "ключ - значение" (Словари, мапы, ассоциативные массивы)

Collection:
* Collection
* Set, List, Map
* HashSet, ArrayList, LinkedList, HashMap


* **Collection** - интерфейс, который определяет базовые методы для работы с простыми наборами элементами

* Все классы, которые наследуются от Collection могут создавать под **свои наборы элементов** Итератор.

* Т.е. итератор созданный для одной коллекции, не может бегать по другой коллекции, потому что он "конфигурировался" только под свою коллекцию.

* **Итератор** - объект, который позволяет последовательно обойти коллекцию (т.е. обратиться к каждому элементу). Итератор указывает не на конкретный элемент, он указывает между ними. Т.е. когда создается итератор, он указывает на пустое место перед самым первым (нулевым) элементом коллекции. Если, метод **.hasNext()** (возвращает либо *true* - есть куда прыгать, либо *false* - прыгать уже некуда) говорит, что перед ним есть элемент (т.е. итератор еще не обошел всю коллекцию), который можно перепрыгнуть, то метод **.next()** (перепрыгивает элемент и его возвращает) делает этот прыжок и встает между элементами. А итератор указывает на тот элемент, который только что перепрыгнул.

* **List** - реализации этого интерфейса представляют собой упорядоченные списки. 
Кроме того, разработчику предоставляется возможность доступа к элементам списка по индексу и значению.

* **ArrayList** - является одной из реализаций интерфейса **List**. Позволяет хранить любые данные, включая **null** в качестве элемента. Реализация основана на обычном массиве. Данную реализацию следует применять, если в процессе работы с коллекцией предполагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции. Подробный анализ и описание можно почитать в этом хабратопике.

* **LinkedList** — является одной из реализаций интерфейса **List**. Позволяет хранить любые данные, включая **null**. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1).

* **Map** -  данный интерфейс предоставляет разработчику базовые методы для работы с данными вида «ключ — значение».

* **HashMap** — является одной из реализаций интерфейса **Map**. В основе данной реализации лежит хэширование - на основе объекта создается индекс корзины, куда будет помещена пара "ключ - значение". Позволяет использовать **null** как в качестве ключа, так и значения. Данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n).

* **Set** - интерфейс, который представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество».

* **HashSet** — реализация интерфейса Set, базирующаяся на **HashMap**. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.