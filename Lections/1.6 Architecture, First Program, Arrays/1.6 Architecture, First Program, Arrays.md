# Инфраструктура Java, Первая программа на Java, Массивы

## Инфраструктура Java

**JVM** - *Java Virtual Machine* - виртуальная машина Java, которая эмулирует систему и железо. Программы на Java запускаются именно в JVM.

**JRE** - *Java Runtime Environment* - непосредственная среда работы JVM. JVM + минимальный набор библиотек Java для возможности запуска приложений на Java. 

**JDK** - *Java Development Kit* - полный набор инструментов разработчика. Именно этот "пакет" позволяет нам писать/создавать приложения на Java. JDK имеет - JRE (которая, в свою очередь, включает в себя JVM) + набор для разработки ПО на Java (компилятор, дебаггер, спецификации и т.д.)

**Транслятор** - переводит один язык программирования на другой язык программирования.

**Компилятор** - разновидность транслятора, который переводит язык программирования высокого уровня (понятного человеку) в язык программирования низкого уровня (понятный машине).

**Интерпретатор** - разновидность транслятора, которая переводит из одного языка программирования в другой - построчно

В компилируемых языках (где используется компилятор) программа сразу после компиляции становится исполняемой, в интерпретируемых языках (где используется интерпретатор) - в процессе запуска. Программы компилируемые работают быстрее, чем интерпретируемые.

Для чего нам нужны интерпретируемые? Потому что машинный код у каждой архитектуры ЭВМ свой. Поэтому, если вы скомпилировали программу для архитектуры Intel, то она может не заработать на AMD. Поэтому для каждого типа архитектуры нужно программу заново компилировать.

В интерпретируемых языках проблема решена с помощью создания интерпретаторов для всех типов архитектур. Таким образом, мы достигаем кроссплатформенности, один и тот же код работает везде без необходимости перекомпилировать его.


Смешанный вариант - хотим обеспечить скорость работы программы и кроссплатформенность - Java. Изначально программа "компилируется" в *байт-код* (файлы с расширением **.class**).

**Байт-код** - это код виртуальной машины Java и он одинаковый для всех типов JVM. В свою очередь, под каждую архитектуру существует свой вариант JVM и поэтому мы достигаем кросс-платформенности. Байт-код - супероптимизированный код, поэтому он выполняется быстрее, чем в случае с обычной интерпретацией.

Пишем код -> Компилируем в байт-код (код, который понимает JVM) -> Интерпретатор внутри JVM работает с байт-кодом.

## Наша первая программа на Java

> ```JAVA
> class НАИМЕНОВАНИЕ_КЛАССА { // Класс всегда называем с большой буквы
> 	//между фигурными скобками находится код класса
> }
> ```

> ```JAVA
> public static void main(String[] args) { 
> 		//Метод main является "точкой вхождения в программу" - работа программы начинается с этого метода
> 		//т.е. код начнет работать между этих фигурных кавычек
> }
> ```


> Это цикл **ПОКА**. Т.е. пока условие в круглых скобках верно/истинно, будет выполняться код внтри фигурных скобок.
> ```JAVA
> while (number != -1) {
> 	//Первая строчка кода
> 	//Вторая строчка кода
> 	//Третья строчка кода
> 	//Четвертая строчка кода
> 	//Пятая строчка кода
> 	//И так до бесконечности (или до конца кода)
> 	//вводится новое значение number
> }
>```

> **new** - ключевое слово (оператор), которое выделяет в памяти место под объект (непосредственно создает объект)

> **%** - оператор деления с остатком
> 13 % 2 = 1\
> 13 % 10 = 3\
> 159 % 10 = 9
> 
> 309 % 10 = 9\
> 309 / 10 = 30\
> 30 % 10 = 0\
> 30 / 10 = 3\
> 3 % 10 = 3\
> 3 / 10 = 0

> Объявление переменной:\
> ТИП_ПЕРЕМЕННОЙ НАИМЕНОВАНИЕ_ПЕРЕМЕННОЙ;\
> Пример:
> ```JAVA
> int number;
> ```


> Инициализация переменной:\
> ТИП_ПЕРЕМЕННОЙ НАИМЕНОВАНИЕ_ПЕРЕМЕННОЙ = КАКОЕ_ЛИБО_ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ;\
> Пример:
> ```JAVA
> int value = 10;
> number = 11; \\ переменная сначала была просто объявлена, а потом уже инициализирована
> ```



```Java
import java.util.Scanner;
//Задача - посчитать сумму всех цифр числа.
//309 - это число, состоящее из цифр 3, 0, 9
class Program {
	public static void main(String[] args) { // для нас это все волшебные слова. Пишем так слово в слово
		//Мы создаем объект, который будет считывать то, что вводит пользователь через клавиатуру
		Scanner scanner = new Scanner(System.in); // для нас это все волшебные слова. Пишем так слово в слово
		//мы в переменную number кладем значение, которое вводится с клавиатуры
		int number = scanner.nextInt(); // scanner.nextInt() - волшебные слова

		while(number != -1) {
			int sumDigits = 0;
			while(number != 0) {
				//На каждом кругу цикла (на каждой итерации) 
				//в переменную temp будет класться последняя цифра цисла number
				int temp = number % 10;
				//Прибавляем цифру к сумме всех цифр данного числа number
				//Сначала, к старому значению sumDigits прибавляется значение temp
				//и только после этого, у sumDigits обновляется значение
				sumDigits = sumDigits + temp;
				//Уменьшаем число на одну цифру (ту цифру, которую мы прибавили к сумме цифр данного числа)
				number = number / 10;
			}
			//Выводит текст в консоль
			System.out.println("Sum all digits: " + sumDigits); // для нас это все волшебные слова. Пишем так слово в слово
			//мы в переменную number кладем значение, которое вводится с клавиатуры
			number = scanner.nextInt();
		}
	}
}
```

## Массивы

**Массив** - ссылочная структура данных, которая хранит в себе элементы одного типа.

У массива доступ к элементам происходит по индексам.

Длина массива - это количество элементов. НАИМЕНОВАНИЕ_ПЕРЕМЕННОЙ.**length**

Диапазон индексов массива всегда равен от 0 до "длина массива - 1".

На что ссылается переменная массива? Переменная массива ссылается на элемент под индексом [0]. 

Инициализация массива:

ТИП_ПЕРЕМЕННОЙ[] НАИМЕНОВАНИЕ_ПЕРЕМЕННОЙ = new ТИП_ПЕРЕМЕННОЙ[ЧИСЛО_ЭЛЕМЕНТОВ];
ТИП_ПЕРЕМЕННОЙ[] НАИМЕНОВАНИЕ_ПЕРЕМЕННОЙ = {ПЕРВЫЙ_ЭЛЕМЕНТ, ВТОРОЙ_ЭЛЕМЕНТ, и.т.д.};

```JAVA
int[] intArray1 = new int[10]; <- правило хорошего тона
int intArray2[] = new int[10]; <- моветон
``` 

```JAVA
class Program {
    public static void main(String[] args) {
        //Мы можем инициализировать сколько угодно значений
        //выделяя под каждое из них переменную
        //Но, если они одного типа, то лучше положить все в массив
        int number1 = 10;
        int number2 = 11;
        int number3 = 12;
        int number4 = 13;
        int number5 = 14;
        //3 варианта инициализции массива:
        //1. Создается массив для N элементов и заполняется значением по умолчанию
        int[] numbersArray = new int[5]; //[0],[0],[0],[0],[0]
        //2. Создается массив, который сразу заполняется нужными значениями
        int[] numbersArray2 = {10, 11, 12, 13, 14};//[10],[11],[12],[13],[14]
        //3. Создается массив, который сразу заполняется нужными значениями 
        //(отличие от второго варианта, что мы кладем в массив переменные, которые содержат в себе значения, а не сами значения)
        int[] numbersArray3 = {number1, number2, number3, number4, number5}; //[10],[11],[12],[13],[14]
        
        //System.out.println(то, что нужно вывести в консоль)
        //в данной записи идет обращение к индексу массива под номером 2
        //т.е. в консоль выведется значение, которое лежит в данном массиве под номером 2
        System.out.println(numbersArray2[2]);
        //здесь будет ошибка, потому что индекса 5 в данном массиве нет
        //потому что всего 5 элементов, индексы которых от 0 до 4, включительно
        System.out.println(numbersArray2[5]); //ошибка, мы вышли за диапазон массива

        //Можно вывести все элементы массива в консоль данным способом (написать вывод каждого элемента):
        System.out.println(numbersArray2[0]);
        System.out.println(numbersArray2[1]);
        System.out.println(numbersArray2[2]);
        System.out.println(numbersArray2[3]);
        System.out.println(numbersArray2[4]);
        
        //Предыдущий подход имеет массу недостатков:
        //1. Если длина массива изменится, то придется дописывать новые строки
        //2. Когда будем выводить каждый элемент - можем, случайно, пропустить какой нибудь элемент
        //3. Если массив будет больше, например - на 100 элементов, то у нас будет 100 строчек кода для вывода всех элементов
        
        //Выход - перебрать массив через цикл
        //Мы никак не зависим от длины массива
        //Перебор массив идет последовательно, следовательно - мы не пропустим никакого элемента
        //Вне зависимости от длины массива, наш код никак не изменится
        for (int i = 0; i < numbersArray2.length; i = i + 1) {
            System.out.println(numbersArray2[i]);
        }
    }
}
```