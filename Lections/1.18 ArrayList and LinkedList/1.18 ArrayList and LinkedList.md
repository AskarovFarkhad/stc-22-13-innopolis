## Связанные списки и списки на основе массива

### ArrayList

**ArrayList<T>** - список на основе массива. Реализует интерфейс **List<T>**. **ArrayList** может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность массива.

Если вызывается конструктор без параметров, то начальная длина массива (начальный размер) равен 10. Но можно использовать конструктор **new ArrayList(int capacity)**, чтобы указать начальный размер массива.

Если места в массиве не достаточно, новый размер рассчитывается по формуле **(oldCapacity * 3) / 2 + 1**. Копирование элементов осуществляется с помощью **native** метода **System.arraycopy()**, который написан не на Java.

> Итоги
> 
> — Быстрый доступ к элементам по индексу за время O(1);\
> — Доступ к элементам по значению за линейное время O(n);\
> — Медленный, когда вставляются и удаляются элементы из «середины» списка;\
> — Позволяет хранить любые значения в том числе и null;

### LinkedList

**LinkedList<T>** — реализует интерфейс **List<T>**. Является представителем двунаправленного списка, где каждый элемент структуры содержит указатели на предыдущий и следующий элементы. Итератор поддерживает обход в обе стороны. Реализует методы получения, удаления и вставки в начало, середину и конец списка. Позволяет добавлять любые элементы в том числе и null.

Только что созданный объект LinkedList, содержит свойства **header** и **size**.

**header** — псевдо-элемент списка. Его значение всегда равно **null**, a свойства **next** и **prev** всегда указывают на первый и последний элемент списка соответственно. Так как на данный момент список еще пуст, свойства **next** и **prev** указывают сами на себя (т.е. на элемент **header**). Размер списка **size** равен 0.

Когда мы кладем в LinkedList новый элемент, сначала создается объект вложенного класса Node. Потом в объект Node кладется сам элемент, который мы добавляем и записываются ссылки в поля Node - в prev записывается ссылка на предыдущий узел (Node), если есть, а в next - записывается ссылка на следующий узел (Node), если есть 

Т.е. говоря простыми словами LinkedList - это цепочка узлов/звеньев (Node), которые хранят в себе сам элемент, ссылку на предыдущий узел и на следующий узел.


[T element; Node prev; Node next;]

Адрес ноды - 0

[190, null, 1]

Адрес ноды - 1

[290, 0, 2]

Адрес ноды - 2

[3809, 1, 3]

Адрес ноды - 3

[29876, 2, null]

> Итоги:
> 
> — Быстрый доступ к элементам в начале и конце (отдельные ссылки под данные элементы) O(1);\
> — Быстрая вставка в начало и конец (отдельные ссылки под данные элементы);\
> — Быстрое удаление из начала и конца (отдельные ссылки под данные элементы);\
> — Доступ к элементам по значению за линейное время O(n);\
> — Очень медленный, когда вставляются и удаляются элементы из «середины» списка за счет последовательного обхода коллекции;\
> — Позволяет хранить любые значения в том числе и null;


**Итератор** - объект, который позволяет последовательно обойти коллекцию (т.е. обратиться к каждому элементу). Итератор указывает не на конкретный элемент,
он указывает между ними. Т.е. когда создается итератор, он указывает на пустое место перед самым первым (нулевым) элементом коллекции. Если, метод
**.hasNext()** (возвращает либо **true** - есть куда прыгать, либо **false** - прыгать уже некуда) говорит, что перед ним есть элемент
(т.е. итератор еще не обошел всю коллекцию), который можно перепрыгнуть, то метод **.next()** (перепрыгивает элемент и его возвращает) делает этот прыжок
и встает между элементами. А итератор указывает на тот элемент, который только что перепрыгнул.

```JAVA
//Пример обхода коллекции через итератор
class Main {
	public static void main(String[] args) {
		ArrayList<Integer> arrayList = new ArrayList<>();

		int i = 0;
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);
		arrayList.add(i++);

		//Теперь создадим итератор для нашего arrayList
		//метод .iterator() возвращает специальный объект, которы настроен под данный список
		//он знает где и как лежат объекты, и знает каким образом их все найти
		//т.е. итератор настроен именно под данный список.
		Iterator<Integer> iterator = arrayList.iterator();
		//у итератора есть метод .hasNext() - он возвращает true, если итератор обошел еще не все элементы,
		// и false, если итератор обошел полностью список (прошел все элементы)
		//Условие такое - пока есть еще элементы, которые надо обойти (пока обошли не все элементы), 
		//то "проваливаемся" внутрь цикла
		while(iterator.hasNext) {
			//Метод .next() перепрыгивает через элемент списка и возвращает его
			//До вызова метода .next()
			//итератор находится перед элементом под индексом 0 (буква V указывает место, на которое указывает сам итератор)	
			//V[0] [1] [2] [3] [4] и т.д.

			//После вызова метода .next() итератор перепрыгивает элемент под индексом 0 и возвращает данный элемент (который перепрыгнул)
			//Теперь итератор уже находится между элементом под индексом 0 и 1
			//(буква V указывает место, на которое указывает сам итератор)

			//[0]V[1] [2] [3] [4] и т.д.

			Integer result = iterator.next();
			System.out.println(result);
			//Можно было написать вот так
			//System.out.println(iterator.next());
		}
	}
}
```
## Скорость работы ArrayList и LinkedList

![Скорость работы ArrayList и LinkedList](https://github.com/BelyiZ/JavaCourses/wiki/images/java-collection-framework/complexity.png)